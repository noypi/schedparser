//line sched.y:2

//TODO Put your favorite license here

// yacc source generated by ebnf2y[1]
// at 2009-03-12 11:23:30.335236099 +0800 PHT
//
//  $ ebnf2y -pkg gen -start Sched sched.ebnf
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
//
//   [1]: http://github.com/cznic/ebnf2y

package gen //TODO real package name
import __yyfmt__ "fmt"

//line sched.y:15
//line sched.y:19
type SchedSymType struct {
	yys  int
	item interface{} //TODO insert real field(s)
}

const COMMA = 57346
const DAY = 57347
const DECIMAL_DIGIT = 57348
const EVERY = 57349
const HRS = 57350
const MINS = 57351
const MONTH = 57352
const NEWLINE = 57353
const ORDINAL = 57354
const SECS = 57355
const TIME = 57356
const FROM = 57357
const OF = 57358
const TO = 57359

var SchedToknames = []string{
	"COMMA",
	"DAY",
	"DECIMAL_DIGIT",
	"EVERY",
	"HRS",
	"MINS",
	"MONTH",
	"NEWLINE",
	"ORDINAL",
	"SECS",
	"TIME",
	"FROM",
	"OF",
	"TO",
}
var SchedStatenames = []string{}

const SchedEofCode = 1
const SchedErrCode = 2
const SchedMaxDepth = 200

//line sched.y:217

type (
	Days       []string
	Days1      []string
	Months     []string
	Months1    []string
	RecurByDay struct {
		Ord    int
		Days   []string
		Months []string
		Clock  string
	}

	RecurByDay1  string
	RecurByDay2  interface{}
	RecurByDay21 []string
	RecurByDay3  string
	RecurByTime  struct {
		N          int
		ClockLbl   string
		ClockRange RecurByTime2
	}

	RecurByTime1 interface{}
	RecurByTime2 struct {
		From string
		To   string
	}
	Sched     interface{}
	Sched1    interface{}
	SchedLine interface{}
	Start     interface{}
)

// End of demo stuff

//line yacctab:1
var SchedExca = []int{
	-1, 1,
	1, -1,
	-2, 0,
}

const SchedNprod = 27
const SchedPrivate = 57344

var SchedTokenNames []string
var SchedStates []string

const SchedLast = 36

var SchedAct = []int{

	33, 20, 23, 16, 17, 35, 30, 25, 18, 7,
	3, 36, 11, 4, 9, 28, 32, 13, 34, 29,
	1, 14, 10, 2, 22, 15, 5, 24, 26, 19,
	8, 6, 31, 27, 21, 12,
}
var SchedPact = []int{

	2, -1000, -1000, -1000, -1000, -1000, -1000, 6, 12, -1000,
	2, -5, -15, -1000, -1000, -13, -1000, -1000, -1000, -7,
	5, 15, -1000, -8, -1000, -1000, -1000, -1000, -1000, 11,
	-17, 14, -1000, -9, 1, -1000, -1000,
}
var SchedPgo = []int{

	0, 35, 34, 33, 32, 31, 30, 29, 28, 27,
	26, 25, 24, 23, 22, 10, 20,
}
var SchedR1 = []int{

	0, 1, 2, 2, 3, 4, 4, 5, 6, 6,
	7, 7, 8, 9, 10, 11, 11, 11, 12, 12,
	13, 14, 14, 15, 15, 15, 16,
}
var SchedR2 = []int{

	0, 2, 0, 3, 2, 0, 3, 4, 1, 1,
	0, 2, 1, 1, 4, 1, 1, 1, 0, 4,
	2, 0, 2, 1, 1, 1, 1,
}
var SchedChk = []int{

	-1000, -16, -13, -15, 11, -10, -5, 7, -6, 12,
	-14, 6, -1, 5, -15, -11, 8, 9, 13, -7,
	16, -2, -12, 15, -9, 14, -8, -3, 10, 4,
	14, -4, 5, 17, 4, 14, 10,
}
var SchedDef = []int{

	0, -2, 26, 21, 23, 24, 25, 8, 0, 9,
	20, 0, 10, 2, 22, 18, 15, 16, 17, 0,
	0, 1, 14, 0, 7, 13, 11, 12, 5, 0,
	0, 4, 3, 0, 0, 19, 6,
}
var SchedTok1 = []int{

	1,
}
var SchedTok2 = []int{

	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17,
}
var SchedTok3 = []int{
	0,
}

//line yaccpar:1

/*	parser for yacc output	*/

var SchedDebug = 0

type SchedLexer interface {
	Lex(lval *SchedSymType) int
	Error(s string)
}

const SchedFlag = -1000

func SchedTokname(c int) string {
	// 4 is TOKSTART above
	if c >= 4 && c-4 < len(SchedToknames) {
		if SchedToknames[c-4] != "" {
			return SchedToknames[c-4]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func SchedStatname(s int) string {
	if s >= 0 && s < len(SchedStatenames) {
		if SchedStatenames[s] != "" {
			return SchedStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func Schedlex1(lex SchedLexer, lval *SchedSymType) int {
	c := 0
	char := lex.Lex(lval)
	if char <= 0 {
		c = SchedTok1[0]
		goto out
	}
	if char < len(SchedTok1) {
		c = SchedTok1[char]
		goto out
	}
	if char >= SchedPrivate {
		if char < SchedPrivate+len(SchedTok2) {
			c = SchedTok2[char-SchedPrivate]
			goto out
		}
	}
	for i := 0; i < len(SchedTok3); i += 2 {
		c = SchedTok3[i+0]
		if c == char {
			c = SchedTok3[i+1]
			goto out
		}
	}

out:
	if c == 0 {
		c = SchedTok2[1] /* unknown char */
	}
	if SchedDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", SchedTokname(c), uint(char))
	}
	return c
}

func SchedParse(Schedlex SchedLexer) int {
	var Schedn int
	var Schedlval SchedSymType
	var SchedVAL SchedSymType
	SchedS := make([]SchedSymType, SchedMaxDepth)

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Schedstate := 0
	Schedchar := -1
	Schedp := -1
	goto Schedstack

ret0:
	return 0

ret1:
	return 1

Schedstack:
	/* put a state and value onto the stack */
	if SchedDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", SchedTokname(Schedchar), SchedStatname(Schedstate))
	}

	Schedp++
	if Schedp >= len(SchedS) {
		nyys := make([]SchedSymType, len(SchedS)*2)
		copy(nyys, SchedS)
		SchedS = nyys
	}
	SchedS[Schedp] = SchedVAL
	SchedS[Schedp].yys = Schedstate

Schednewstate:
	Schedn = SchedPact[Schedstate]
	if Schedn <= SchedFlag {
		goto Scheddefault /* simple state */
	}
	if Schedchar < 0 {
		Schedchar = Schedlex1(Schedlex, &Schedlval)
	}
	Schedn += Schedchar
	if Schedn < 0 || Schedn >= SchedLast {
		goto Scheddefault
	}
	Schedn = SchedAct[Schedn]
	if SchedChk[Schedn] == Schedchar { /* valid shift */
		Schedchar = -1
		SchedVAL = Schedlval
		Schedstate = Schedn
		if Errflag > 0 {
			Errflag--
		}
		goto Schedstack
	}

Scheddefault:
	/* default state action */
	Schedn = SchedDef[Schedstate]
	if Schedn == -2 {
		if Schedchar < 0 {
			Schedchar = Schedlex1(Schedlex, &Schedlval)
		}

		/* look through exception table */
		xi := 0
		for {
			if SchedExca[xi+0] == -1 && SchedExca[xi+1] == Schedstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Schedn = SchedExca[xi+0]
			if Schedn < 0 || Schedn == Schedchar {
				break
			}
		}
		Schedn = SchedExca[xi+1]
		if Schedn < 0 {
			goto ret0
		}
	}
	if Schedn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Schedlex.Error("syntax error")
			Nerrs++
			if SchedDebug >= 1 {
				__yyfmt__.Printf("%s", SchedStatname(Schedstate))
				__yyfmt__.Printf(" saw %s\n", SchedTokname(Schedchar))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Schedp >= 0 {
				Schedn = SchedPact[SchedS[Schedp].yys] + SchedErrCode
				if Schedn >= 0 && Schedn < SchedLast {
					Schedstate = SchedAct[Schedn] /* simulate a shift of "error" */
					if SchedChk[Schedstate] == SchedErrCode {
						goto Schedstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if SchedDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", SchedS[Schedp].yys)
				}
				Schedp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if SchedDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", SchedTokname(Schedchar))
			}
			if Schedchar == SchedEofCode {
				goto ret1
			}
			Schedchar = -1
			goto Schednewstate /* try again in the same state */
		}
	}

	/* reduction by production Schedn */
	if SchedDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Schedn, SchedStatname(Schedstate))
	}

	Schednt := Schedn
	Schedpt := Schedp
	_ = Schedpt // guard against "declared and not used"

	Schedp -= SchedR2[Schedn]
	SchedVAL = SchedS[Schedp+1]

	/* consult goto table to find next state */
	Schedn = SchedR1[Schedn]
	Schedg := SchedPgo[Schedn]
	Schedj := Schedg + SchedS[Schedp].yys + 1

	if Schedj >= SchedLast {
		Schedstate = SchedAct[Schedg]
	} else {
		Schedstate = SchedAct[Schedj]
		if SchedChk[Schedstate] != -Schedn {
			Schedstate = SchedAct[Schedg]
		}
	}
	// dummy call; replaced with literal code
	switch Schednt {

	case 1:
		//line sched.y:78
		{
			SchedVAL.item = append([]string{SchedS[Schedpt-1].item.(string)}, SchedS[Schedpt-0].item.([]string)...)
		}
	case 2:
		//line sched.y:84
		{
			SchedVAL.item = []string{}
		}
	case 3:
		//line sched.y:88
		{
			SchedVAL.item = append(SchedS[Schedpt-2].item.([]string), SchedS[Schedpt-0].item.(string))
		}
	case 4:
		//line sched.y:94
		{
			SchedVAL.item = append([]string{SchedS[Schedpt-1].item.(string)}, SchedS[Schedpt-0].item.([]string)...)
		}
	case 5:
		//line sched.y:100
		{
			SchedVAL.item = []string{}
		}
	case 6:
		//line sched.y:104
		{
			SchedVAL.item = append(SchedS[Schedpt-2].item.([]string), SchedS[Schedpt-0].item.(string))
		}
	case 7:
		//line sched.y:110
		{
			var ord int
			var ok bool
			if ord, ok = SchedS[Schedpt-3].item.(int); !ok {
				ord = -1
			}
			SchedVAL.item = RecurByDay{Ord: ord, Days: SchedS[Schedpt-2].item.([]string), Months: SchedS[Schedpt-1].item.([]string), Clock: SchedS[Schedpt-0].item.(string)} //TODO 7
		}
	case 8:
		//line sched.y:122
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 8
		}
	case 9:
		//line sched.y:126
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 9
		}
	case 10:
		//line sched.y:132
		{
			SchedVAL.item = []string{}
		}
	case 11:
		//line sched.y:136
		{
			SchedVAL.item = SchedS[Schedpt-0].item
		}
	case 12:
		//line sched.y:142
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 12
		}
	case 13:
		//line sched.y:148
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 13
		}
	case 14:
		//line sched.y:154
		{
			SchedVAL.item = RecurByTime{N: SchedS[Schedpt-2].item.(int), ClockLbl: SchedS[Schedpt-1].item.(string), ClockRange: SchedS[Schedpt-0].item.(RecurByTime2)}
		}
	case 15:
		//line sched.y:160
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 15
		}
	case 16:
		//line sched.y:164
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 16
		}
	case 17:
		//line sched.y:168
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 17
		}
	case 18:
		//line sched.y:174
		{
			SchedVAL.item = RecurByTime2{}
		}
	case 19:
		//line sched.y:178
		{
			SchedVAL.item = RecurByTime2{From: SchedS[Schedpt-2].item.(string), To: SchedS[Schedpt-0].item.(string)}
		}
	case 20:
		//line sched.y:184
		{
		}
	case 21:
		//line sched.y:189
		{
		}
	case 22:
		//line sched.y:192
		{
		}
	case 23:
		//line sched.y:197
		{
		}
	case 24:
		//line sched.y:200
		{
			if v, ok := Schedlex.(*SchedLex); ok {
				v.OnSched(SchedS[Schedpt-0].item)
			}
		}
	case 25:
		//line sched.y:206
		{
			if v, ok := Schedlex.(*SchedLex); ok {
				v.OnSched(SchedS[Schedpt-0].item)
			}
		}
	case 26:
		//line sched.y:214
		{
		}
	}
	goto Schedstack /* stack new state and value */
}
