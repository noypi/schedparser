//line sched.y:2

//TODO Put your favorite license here

// yacc source generated by ebnf2y[1]
// at 2009-03-12 11:23:30.335236099 +0800 PHT
//
//  $ ebnf2y -pkg gen -start Sched sched.ebnf
//
// CAUTION: If this file is a Go source file (*.go), it was generated
// automatically by '$ go tool yacc' from a *.y file - DO NOT EDIT in that case!
//
//   [1]: http://github.com/cznic/ebnf2y

package gen //TODO real package name
import __yyfmt__ "fmt"

//line sched.y:15
//TODO required only be the demo _dump function
import (
	"bytes"
	"fmt"
	"strings"

	"github.com/cznic/strutil"
)

//line sched.y:28
type SchedSymType struct {
	yys  int
	item interface{} //TODO insert real field(s)
}

const COMMA = 57346
const DAY = 57347
const DECIMAL_DIGIT = 57348
const EVERY = 57349
const HRS = 57350
const MINS = 57351
const MONTH = 57352
const NEWLINE = 57353
const ORDINAL = 57354
const SECS = 57355
const TIME = 57356
const FROM = 57357
const OF = 57358
const TO = 57359

var SchedToknames = []string{
	"COMMA",
	"DAY",
	"DECIMAL_DIGIT",
	"EVERY",
	"HRS",
	"MINS",
	"MONTH",
	"NEWLINE",
	"ORDINAL",
	"SECS",
	"TIME",
	"FROM",
	"OF",
	"TO",
}
var SchedStatenames = []string{}

const SchedEofCode = 1
const SchedErrCode = 2
const SchedMaxDepth = 200

//line sched.y:221

//TODO remove demo stuff below

var _parserResult interface{}

type (
	Days         interface{}
	Days1        interface{}
	Months       interface{}
	Months1      interface{}
	RecurByDay   interface{}
	RecurByDay1  interface{}
	RecurByDay2  interface{}
	RecurByDay21 interface{}
	RecurByDay3  interface{}
	RecurByTime  interface{}
	RecurByTime1 interface{}
	RecurByTime2 interface{}
	Sched        interface{}
	Sched1       interface{}
	SchedLine    interface{}
	Start        interface{}
)

func _dump() {
	s := fmt.Sprintf("%#v", _parserResult)
	s = strings.Replace(s, "%", "%%", -1)
	s = strings.Replace(s, "{", "{%i\n", -1)
	s = strings.Replace(s, "}", "%u\n}", -1)
	s = strings.Replace(s, ", ", ",\n", -1)
	var buf bytes.Buffer
	strutil.IndentFormatter(&buf, ". ").Format(s)
	buf.WriteString("\n")
	a := strings.Split(buf.String(), "\n")
	for _, v := range a {
		if strings.HasSuffix(v, "(nil)") || strings.HasSuffix(v, "(nil),") {
			continue
		}

		fmt.Println(v)
	}
}

// End of demo stuff

//line yacctab:1
var SchedExca = []int{
	-1, 1,
	1, -1,
	-2, 0,
}

const SchedNprod = 27
const SchedPrivate = 57344

var SchedTokenNames []string
var SchedStates []string

const SchedLast = 36

var SchedAct = []int{

	33, 20, 23, 16, 17, 35, 30, 25, 18, 7,
	3, 36, 11, 4, 9, 28, 32, 13, 34, 29,
	1, 14, 10, 2, 22, 15, 5, 24, 26, 19,
	8, 6, 31, 27, 21, 12,
}
var SchedPact = []int{

	2, -1000, -1000, -1000, -1000, -1000, -1000, 6, 12, -1000,
	2, -5, -15, -1000, -1000, -13, -1000, -1000, -1000, -7,
	5, 15, -1000, -8, -1000, -1000, -1000, -1000, -1000, 11,
	-17, 14, -1000, -9, 1, -1000, -1000,
}
var SchedPgo = []int{

	0, 35, 34, 33, 32, 31, 30, 29, 28, 27,
	26, 25, 24, 23, 22, 10, 20,
}
var SchedR1 = []int{

	0, 1, 2, 2, 3, 4, 4, 5, 6, 6,
	7, 7, 8, 9, 10, 11, 11, 11, 12, 12,
	13, 14, 14, 15, 15, 15, 16,
}
var SchedR2 = []int{

	0, 2, 0, 3, 2, 0, 3, 4, 1, 1,
	0, 2, 1, 1, 4, 1, 1, 1, 0, 4,
	2, 0, 2, 1, 1, 1, 1,
}
var SchedChk = []int{

	-1000, -16, -13, -15, 11, -10, -5, 7, -6, 12,
	-14, 6, -1, 5, -15, -11, 8, 9, 13, -7,
	16, -2, -12, 15, -9, 14, -8, -3, 10, 4,
	14, -4, 5, 17, 4, 14, 10,
}
var SchedDef = []int{

	0, -2, 26, 21, 23, 24, 25, 8, 0, 9,
	20, 0, 10, 2, 22, 18, 15, 16, 17, 0,
	0, 1, 14, 0, 7, 13, 11, 12, 5, 0,
	0, 4, 3, 0, 0, 19, 6,
}
var SchedTok1 = []int{

	1,
}
var SchedTok2 = []int{

	2, 3, 4, 5, 6, 7, 8, 9, 10, 11,
	12, 13, 14, 15, 16, 17,
}
var SchedTok3 = []int{
	0,
}

//line yaccpar:1

/*	parser for yacc output	*/

var SchedDebug = 0

type SchedLexer interface {
	Lex(lval *SchedSymType) int
	Error(s string)
}

const SchedFlag = -1000

func SchedTokname(c int) string {
	// 4 is TOKSTART above
	if c >= 4 && c-4 < len(SchedToknames) {
		if SchedToknames[c-4] != "" {
			return SchedToknames[c-4]
		}
	}
	return __yyfmt__.Sprintf("tok-%v", c)
}

func SchedStatname(s int) string {
	if s >= 0 && s < len(SchedStatenames) {
		if SchedStatenames[s] != "" {
			return SchedStatenames[s]
		}
	}
	return __yyfmt__.Sprintf("state-%v", s)
}

func Schedlex1(lex SchedLexer, lval *SchedSymType) int {
	c := 0
	char := lex.Lex(lval)
	if char <= 0 {
		c = SchedTok1[0]
		goto out
	}
	if char < len(SchedTok1) {
		c = SchedTok1[char]
		goto out
	}
	if char >= SchedPrivate {
		if char < SchedPrivate+len(SchedTok2) {
			c = SchedTok2[char-SchedPrivate]
			goto out
		}
	}
	for i := 0; i < len(SchedTok3); i += 2 {
		c = SchedTok3[i+0]
		if c == char {
			c = SchedTok3[i+1]
			goto out
		}
	}

out:
	if c == 0 {
		c = SchedTok2[1] /* unknown char */
	}
	if SchedDebug >= 3 {
		__yyfmt__.Printf("lex %s(%d)\n", SchedTokname(c), uint(char))
	}
	return c
}

func SchedParse(Schedlex SchedLexer) int {
	var Schedn int
	var Schedlval SchedSymType
	var SchedVAL SchedSymType
	SchedS := make([]SchedSymType, SchedMaxDepth)

	Nerrs := 0   /* number of errors */
	Errflag := 0 /* error recovery flag */
	Schedstate := 0
	Schedchar := -1
	Schedp := -1
	goto Schedstack

ret0:
	return 0

ret1:
	return 1

Schedstack:
	/* put a state and value onto the stack */
	if SchedDebug >= 4 {
		__yyfmt__.Printf("char %v in %v\n", SchedTokname(Schedchar), SchedStatname(Schedstate))
	}

	Schedp++
	if Schedp >= len(SchedS) {
		nyys := make([]SchedSymType, len(SchedS)*2)
		copy(nyys, SchedS)
		SchedS = nyys
	}
	SchedS[Schedp] = SchedVAL
	SchedS[Schedp].yys = Schedstate

Schednewstate:
	Schedn = SchedPact[Schedstate]
	if Schedn <= SchedFlag {
		goto Scheddefault /* simple state */
	}
	if Schedchar < 0 {
		Schedchar = Schedlex1(Schedlex, &Schedlval)
	}
	Schedn += Schedchar
	if Schedn < 0 || Schedn >= SchedLast {
		goto Scheddefault
	}
	Schedn = SchedAct[Schedn]
	if SchedChk[Schedn] == Schedchar { /* valid shift */
		Schedchar = -1
		SchedVAL = Schedlval
		Schedstate = Schedn
		if Errflag > 0 {
			Errflag--
		}
		goto Schedstack
	}

Scheddefault:
	/* default state action */
	Schedn = SchedDef[Schedstate]
	if Schedn == -2 {
		if Schedchar < 0 {
			Schedchar = Schedlex1(Schedlex, &Schedlval)
		}

		/* look through exception table */
		xi := 0
		for {
			if SchedExca[xi+0] == -1 && SchedExca[xi+1] == Schedstate {
				break
			}
			xi += 2
		}
		for xi += 2; ; xi += 2 {
			Schedn = SchedExca[xi+0]
			if Schedn < 0 || Schedn == Schedchar {
				break
			}
		}
		Schedn = SchedExca[xi+1]
		if Schedn < 0 {
			goto ret0
		}
	}
	if Schedn == 0 {
		/* error ... attempt to resume parsing */
		switch Errflag {
		case 0: /* brand new error */
			Schedlex.Error("syntax error")
			Nerrs++
			if SchedDebug >= 1 {
				__yyfmt__.Printf("%s", SchedStatname(Schedstate))
				__yyfmt__.Printf(" saw %s\n", SchedTokname(Schedchar))
			}
			fallthrough

		case 1, 2: /* incompletely recovered error ... try again */
			Errflag = 3

			/* find a state where "error" is a legal shift action */
			for Schedp >= 0 {
				Schedn = SchedPact[SchedS[Schedp].yys] + SchedErrCode
				if Schedn >= 0 && Schedn < SchedLast {
					Schedstate = SchedAct[Schedn] /* simulate a shift of "error" */
					if SchedChk[Schedstate] == SchedErrCode {
						goto Schedstack
					}
				}

				/* the current p has no shift on "error", pop stack */
				if SchedDebug >= 2 {
					__yyfmt__.Printf("error recovery pops state %d\n", SchedS[Schedp].yys)
				}
				Schedp--
			}
			/* there is no state on the stack with an error shift ... abort */
			goto ret1

		case 3: /* no shift yet; clobber input char */
			if SchedDebug >= 2 {
				__yyfmt__.Printf("error recovery discards %s\n", SchedTokname(Schedchar))
			}
			if Schedchar == SchedEofCode {
				goto ret1
			}
			Schedchar = -1
			goto Schednewstate /* try again in the same state */
		}
	}

	/* reduction by production Schedn */
	if SchedDebug >= 2 {
		__yyfmt__.Printf("reduce %v in:\n\t%v\n", Schedn, SchedStatname(Schedstate))
	}

	Schednt := Schedn
	Schedpt := Schedp
	_ = Schedpt // guard against "declared and not used"

	Schedp -= SchedR2[Schedn]
	SchedVAL = SchedS[Schedp+1]

	/* consult goto table to find next state */
	Schedn = SchedR1[Schedn]
	Schedg := SchedPgo[Schedn]
	Schedj := Schedg + SchedS[Schedp].yys + 1

	if Schedj >= SchedLast {
		Schedstate = SchedAct[Schedg]
	} else {
		Schedstate = SchedAct[Schedj]
		if SchedChk[Schedstate] != -Schedn {
			Schedstate = SchedAct[Schedg]
		}
	}
	// dummy call; replaced with literal code
	switch Schednt {

	case 1:
		//line sched.y:87
		{
			SchedVAL.item = []Days{SchedS[Schedpt-1].item, SchedS[Schedpt-0].item} //TODO 1
		}
	case 2:
		//line sched.y:93
		{
			SchedVAL.item = []Days1(nil) //TODO 2
		}
	case 3:
		//line sched.y:97
		{
			SchedVAL.item = append(SchedS[Schedpt-2].item.([]Days1), SchedS[Schedpt-1].item, SchedS[Schedpt-0].item) //TODO 3
		}
	case 4:
		//line sched.y:103
		{
			SchedVAL.item = []Months{SchedS[Schedpt-1].item, SchedS[Schedpt-0].item} //TODO 4
		}
	case 5:
		//line sched.y:109
		{
			SchedVAL.item = []Months1(nil) //TODO 5
		}
	case 6:
		//line sched.y:113
		{
			SchedVAL.item = append(SchedS[Schedpt-2].item.([]Months1), SchedS[Schedpt-1].item, SchedS[Schedpt-0].item) //TODO 6
		}
	case 7:
		//line sched.y:119
		{
			SchedVAL.item = []RecurByDay{SchedS[Schedpt-3].item, SchedS[Schedpt-2].item, SchedS[Schedpt-1].item, SchedS[Schedpt-0].item} //TODO 7
		}
	case 8:
		//line sched.y:125
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 8
		}
	case 9:
		//line sched.y:129
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 9
		}
	case 10:
		//line sched.y:135
		{
			SchedVAL.item = nil //TODO 10
		}
	case 11:
		//line sched.y:139
		{
			SchedVAL.item = []RecurByDay2{"of", SchedS[Schedpt-0].item} //TODO 11
		}
	case 12:
		//line sched.y:145
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 12
		}
	case 13:
		//line sched.y:151
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 13
		}
	case 14:
		//line sched.y:157
		{
			SchedVAL.item = []RecurByTime{SchedS[Schedpt-3].item, SchedS[Schedpt-2].item, SchedS[Schedpt-1].item, SchedS[Schedpt-0].item} //TODO 14
		}
	case 15:
		//line sched.y:163
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 15
		}
	case 16:
		//line sched.y:167
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 16
		}
	case 17:
		//line sched.y:171
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 17
		}
	case 18:
		//line sched.y:177
		{
			SchedVAL.item = nil //TODO 18
		}
	case 19:
		//line sched.y:181
		{
			SchedVAL.item = []RecurByTime2{"from", SchedS[Schedpt-2].item, "to", SchedS[Schedpt-0].item} //TODO 19
		}
	case 20:
		//line sched.y:187
		{
			SchedVAL.item = []Sched{SchedS[Schedpt-1].item, SchedS[Schedpt-0].item} //TODO 20
		}
	case 21:
		//line sched.y:193
		{
			SchedVAL.item = []Sched1(nil) //TODO 21
		}
	case 22:
		//line sched.y:197
		{
			SchedVAL.item = append(SchedS[Schedpt-1].item.([]Sched1), SchedS[Schedpt-0].item) //TODO 22
		}
	case 23:
		//line sched.y:203
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 23
		}
	case 24:
		//line sched.y:207
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 24
		}
	case 25:
		//line sched.y:211
		{
			SchedVAL.item = SchedS[Schedpt-0].item //TODO 25
		}
	case 26:
		//line sched.y:217
		{
			_parserResult = SchedS[Schedpt-0].item //TODO 26
		}
	}
	goto Schedstack /* stack new state and value */
}
